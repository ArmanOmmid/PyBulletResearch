# -*- coding: utf-8 -*-
"""PyBullet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nr-nG8NkRWmGwF5TPV011MJvWNMwLkJE
"""

token = "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"
# Force_Redownload = 1
# try:
#     if Force_Redownload: raise Exception("Force Redownload")
#     import PyBulletResearch
# except Exception as E:
#     print("[INFO] Downloading Code from GitHub.")
#     !rm -rf PyBulletResearch
#     !git clone https://ArmanOmmid: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@github.com/ArmanOmmid/PyBulletResearch.git
# finally:
#     pass

# !pip install pybullet

import numpy as np
import pybullet as p
import pybullet_data
import time

# # initialize environment 
# p.connect(p.DIRECT) # Since we're in colab, we cant render in a window... should use "config"?
# p.resetSimulation()
# p.setAdditionalSearchPath(pybullet_data.getDataPath())
# p.setGravity(0, 0, -9.8)
# p.setRealTimeSimulation(0)

# # laod assets
# planeid = p.loadURDF("plane.urdf", [0, 0, 0], [0, 0, 0, 1])
# targid = p.loadURDF("franka_panda/panda.urdf", [0, 0, 0], [0, 0, 0, 1], useFixedBase = True)
# obj_of_focus = targid

# # getting link and joint state info
# p.getNumJoints(targid)

# for i in range(p.getNumJoints(targid)):
#     print(p.getJointInfo(targid, i))

# jointid = 4
# jointInfo = p.getJointInfo(targid, jointid)
# jtype = jointInfo[2]
# jlower = jointInfo[8]
# jupper = jointInfo[9]
# print(jlower, jupper) # minimum and maximum movement range of the joint

# # changing joint angles (applying forces)
# for step in range(500):
#     joint_two_targ = np.random.uniform(jlower, jupper)
#     joint_four_targ = np.random.uniform(jlower, jupper)
#     p.setJointMotorControlArray(targid, [2, 4], p.POSITION_CONTROL, targetPositions = [joint_two_targ, joint_four_targ])
#     p.stepSimulation()
#     # print(p.getJointStates(targid, [2, 4]))
#     # if you need to query joint states or link states to update observation
#     # print(p.getLinkStates(targid, [2, 4]))

class ArmEnv():
    def __init__(self, GUI=False):
        self.state = self.init_state(GUI=GUI)
        self.step_count = 0
    
    def init_state(self, GUI=False):
        if GUI:
            p.connect(p.GUI)
        else:
            p.connect(p.DIRECT)
        p.resetSimulation()
        p.setAdditionalSearchPath(pybullet_data.getDataPath())
        p.setGravity(0, 0, -9.8)
        planeid = p.loadURDF("plane.urdf", [0, 0, 0], [0, 0, 0, 1])
        self.pandaUid = p.loadURDF("franka_panda/panda.urdf", [0, 0, 0], [0, 0, 0, 1], useFixedBase = True)

        jointid = 4
        jointInfo = p.getJointInfo(self.pandaUid, jointid)
        jtype = jointInfo[2]
        self.jlower = jointInfo[8]
        self.jupper = jointInfo[9]

        if GUI:
            self.focus_pos, self.focus_orientation = p.getBasePositionAndOrientation(self.pandaUid)
            p.resetDebugVisualizerCamera(cameraDistance=3, cameraYaw=-20, cameraPitch=-30, cameraTargetPosition=self.focus_pos)
        finger_pos = p.getLinkState(self.pandaUid, 9)[0] # Index 0 is just the position in 3d space
        obs = np.array(finger_pos).flatten()
        return obs

    def reset(self):
        p.disconnect()
        self.step_count = 0

    def random_action(self):
        return np.random.uniform(self.jlower, self.jupper)

    def step(self, action):
        self.step_count += 1
        # We're going to be modifying the 4th joint
        # We're going to be applying position control, not velocity control or torque control
        # We're going to apply the action (being the new target position in this case) ... should really be new_position instead of action
        p.setJointMotorControlArray(self.pandaUid, [4], p.POSITION_CONTROL, [action]) 
        p.stepSimulation
        finger_pos = p.getLinkState(self.pandaUid, 9)[0]
        done = False

        # if self.step_count >= 50: # Termiante at 50 steps; arbitrarily
        #     finger_pos = p.getLinkState(self.pandaUid, 9)[0]
        #     done = True
        #     obs = np.array([finger_pos]).flatten()
        #     self.state = obs
        #     reward = -1 # arbitrary reward
        #     self.reset()
        #     return reward, done

        obs = np.array([finger_pos]).flatten()
        self.state = obs
        reward = -1 # arbitrary reward
        return reward, done

env = ArmEnv(True)
for step in range(500):
    action = env.random_action()
    a, b = env.step(action)
    # print(env.state)
    if b: break
    p.stepSimulation()
    time.sleep(1./240.)
    # print(p.getLinkStates(targid, [2, 4]))